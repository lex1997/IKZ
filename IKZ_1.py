import math as m
import time

start_time = time.time()

Fi = (m.sqrt(5) - 1) / 2 # константа фи для вычисления
eps = 10 ** (-10) # константа близкая к нулю
data1 = []
data2 = []
data3 = []


def F(x):
    return (x - 4) ** 2 + m.log(x - 1) # наша вычисляемая функция


def dF(x):
    return 2 * (x - 4) + 1 / (x - 1) # первая производная


def ddF(x):
    return 2 - 1 / ((x - 1) ** 2) # вторая производная


def golden_ratio(a, b, n): # метод золотого сечения с входными границами а и б, первая меньше примерного решения, вторая - больше
    data1.append([n, a])  # добавляем данные в массив дата
    if abs((Fi ** n) * (b - a)) < eps: return  # условия выхода из рекурсивного цикла, остановки функции, модуль фи в степени номера итерации умножить на разницу двух (с двух сторон) найденных приближенных к решению границ
    x1 = a - (Fi - 1) * (b - a) # вычисление первой предполагаемой границы согласно заданному теорией выражению для границы а, для сохращения расстояния между границами
    x2 = a + Fi * (b - a)    # вычисление второй предполагаемой границы согласно заданному теорией выражению для границы б, для сохращения расстояния между границами
    if F(x1) < F(x2): # сравнение значений функции для найденных предполагаемых значений
        golden_ratio(a, x2, n + 1) # если значение функции в точке х1 меньше, минимум дальше от точки х2, чтобы минимум не потерять, берём с запасом, сохраняем значение х2 в точку б и снова вызываем нашу функцию с новыми параметрами
    else:
        golden_ratio(x1, b, n + 1) # если значение функции в точке х2 меньше, минимум дальше от точки х1, сохраняем значение х1 в точку а и снова вызываем нашу функцию с новыми параметрами


def newton(xk, xk1, n): # рекурсивный метод ньютона со входными параметрами текущей точки xk1 и предыдущей точкой xk
    data2.append([n, xk, xk1])  # добавляем данные в массив дата
    if abs(F(xk1) - F(xk)) < eps: return # завершаем рекурсивное выполнение функции когда разница между значенями функции в текущей и предыдущей точках станет меньше заданного эпсилон
    newton(xk1, xk - dF(xk) / ddF(xk1), n)


def tangents(a, b, n):
    data3.append([n, a, b])
    if (abs(dF(a)) < eps or abs(dF(b)) < eps): return
    x = (b * dF(b) - a * dF(a) - (F(b) - F(a))) / (dF(b) - dF(a))
    if dF(x) < 0:
        tangents(x, b, n + 1)
    else:
        tangents(a, x, n + 1)


if __name__ == "__main__":

    a = 2
    b = 4
    n = 1
    golden_ratio(a, b, n)
    print(f'golden_ratio = {data1[-1]}')
    newton(2, 4, n)
    print(f'newton = {data2[-1]}')
    tangents(a, b, n)
    print(f'tangents = {data3[-1]}')
